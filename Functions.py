import numpy as np
import pandas as pd
from numpy import genfromtxt

import tensorflow as tf
from tensorflow.keras import layers, Input
from tensorflow.keras.layers import Input, Dense, Activation, ZeroPadding2D, BatchNormalization, Flatten, Conv2D
from tensorflow.keras.layers import AveragePooling2D, MaxPooling2D, Dropout, GlobalMaxPooling2D, GlobalAveragePooling2D
from tensorflow.keras.models import Model
from tensorflow.keras.preprocessing import image
from IPython.display import SVG

from sklearn.model_selection import KFold
from sklearn.model_selection import train_test_split

import matplotlib.pyplot as plt
from matplotlib.pyplot import imshow
from IPython.display import Image

# Load the data generated by opencv c++,
# isCentered used for centering pixels by subtracting mean from each pixel
# isGray used for loading the data of grayscale images


def loadDataset(isCentered, isGray):
    path = ''
    classes = np.array([0, 1])

    train_dataset_x = genfromtxt(
        path + 'FinalDataset/images_g.csv', delimiter=',')  # generated by opencv c++
    train_dataset_y = genfromtxt(
        path + 'FinalDataset/labels_g.csv', delimiter=',')  # generated by opencv c++
    train_set_x_orig = train_dataset_x  # train set features
    train_set_y_orig = train_dataset_y  # train set labels

    if isGray:
        X_train_orig = np.reshape(train_set_x_orig, (6000, 32, 32, 1))
    else:
        X_train_orig = np.reshape(train_set_x_orig, (6000, 32, 32, 3))
    # Spliting data to train and test
    X_train, X_test, y_train, y_test = train_test_split(
        X_train_orig, train_set_y_orig, test_size=0.1, random_state=23)

    if isCentered:

        meansTrain = X_train.mean(axis=(0, 1), dtype='float64')
        meansTest = X_test.mean(axis=(0, 1), dtype='float64')
        # per-channel centering of pixels
        X_train -= meansTrain
        X_test -= meansTest

    # normalize data
    X_train = X_train/255.
    X_test = X_test/255.

    print("number of training examples = " + str(X_train.shape[0]))
    print("number of test examples = " + str(X_test.shape[0]))
    print("X_train shape: " + str(X_train.shape))
    print("Y_train shape: " + str(y_train.shape))
    print("X_test shape: " + str(X_test.shape))
    print("Y_test shape: " + str(y_test.shape))

    return classes, X_train, y_train, X_test, y_test


# Defining CNN model
def BananaModel(input_shape):

    X_input = Input(input_shape)

    X = X_input

    X = ZeroPadding2D((3, 3))(X_input)

    X = Conv2D(32, kernel_size=[5, 5], strides=1,
               padding="same", name='conv0')(X)
    X = BatchNormalization(axis=3, name='bn0')(X)
    X = Activation('relu')(X)
    X = MaxPooling2D((2, 2), name='max_pool')(X)

    X = Conv2D(64, kernel_size=[5, 5], strides=1,
               padding="same", name='conv1')(X)
    X = BatchNormalization(axis=3, name='bn1')(X)
    X = Activation('relu')(X)
    X = MaxPooling2D((2, 2), name='max_pool2')(X)

    X = Conv2D(128, kernel_size=[5, 5], strides=1,
               padding="same", name='conv2')(X)
    X = BatchNormalization(axis=3, name='bn2')(X)
    X = Activation('relu')(X)
    X = MaxPooling2D((2, 2), name='max_pool3')(X)

    X = Conv2D(128, kernel_size=[5, 5], strides=1,
               padding="same", name='conv3')(X)
    X = BatchNormalization(axis=3, name='bn3')(X)
    X = Activation('relu')(X)
    X = MaxPooling2D((2, 2), name='max_pool4')(X)

    X = Flatten()(X)
    X = Dense(128, activation='relu', name='rl')(X)
    X = Dense(1, activation='sigmoid', name='sm')(X)
    # Create model. This creates your Keras model instance, you'll use this instance to train/test the model.
    model = Model(inputs=X_input, outputs=X, name='banana_model')

    return model


# Read test data for predicting on them
# filename is the image filename
# modelType specifies the type of model that is loaded for predition
# model is the instance of CNN model
# will return array of patches with their scores and their coordinates
def readPic(filename, modelType, model):

    if modelType == 'rgb':
        img_path = '../testRgb/'+str(filename)+'.png'
        srcImage = image.load_img(img_path, target_size=(256, 256))
    elif modelType == 'gray':
        img_path = '../testGray/'+str(filename)+'.png'
        srcImage = image.load_img(img_path, target_size=(
            256, 256), color_mode='grayscale')
    elif modelType == 'gauss':
        img_path = '../testGauss/'+str(filename)+'.png'
        srcImage = image.load_img(img_path, target_size=(256, 256))
    elif modelType == 'center':
        img_path = '../testRgb/'+str(filename)+'.png'
        srcImage = image.load_img(img_path, target_size=(256, 256))

    # imshow(srcImage)
    arrayImg = image.img_to_array(srcImage)

    patchsList = []

    for x in range(0, 256, 16):
        for y in range(0, 256, 16):
            if(x < 225 and y < 225):
                patch = {}
                img = arrayImg[x:x+32, y:y+32, :]
                img = np.expand_dims(img, axis=0)
                img = arrayImg[x:x+32, y:y+32, :]
                img = np.expand_dims(img, axis=0)

                if modelType == 'center':
                    means = img.mean(axis=(0, 1), dtype='float64')
                    print('Means: %s' % means)
                    print('Mins: %s, Maxs: %s' %
                          (img.min(axis=(0, 1)), img.max(axis=(0, 1))))
                    # per-channel centering of pixels
                    img -= means
                    # confirm it had the desired effect
                    means = img.mean(axis=(0, 1), dtype='float64')
                    print('Means: %s' % means)
                    print('Mins: %s, Maxs: %s' %
                          (img.min(axis=(0, 1)), img.max(axis=(0, 1))))
                img = img / 255

                score = model.predict(img)
                #print(str(x) + "-" + str(y))
                if score[0][0] > 0.7:
                    patch['score'] = score[0][0]
                    patch['xmin'] = x
                    patch['ymin'] = y
                    patch['xmax'] = x+32
                    patch['ymax'] = y+32
                    patch['selected'] = 0
                    patchsList.append(patch)
    return patchsList

# for sorting


def takeScore(elem):
    return elem['score']

# analyze the neighbours of patch for finding the banana zone
# will return array of neighbours with their coordinates


def findNeighbours(patchsList):

    patchsList.sort(key=takeScore, reverse=True)

    if(len(patchsList) == 0):
        return []

    thresh = 16
    neighbours = []
    finalSquares = []
    square = {}
    patchsList[0]['selected'] = 1
    neighbours.append(patchsList[0])
    neighCounter = 1
    pointer = 0
    flag = 0
    while (flag != 1):
        flag = 1
        for p in range(0, neighCounter):
            xmin = neighbours[p]['xmin']
            xmax = neighbours[p]['xmax']
            ymin = neighbours[p]['ymin']
            ymax = neighbours[p]['ymax']
            score = neighbours[p]['score']
            for j in range(0, len(patchsList)):
                if(patchsList[j]['score'] > 0.95):
                    patchXmin = patchsList[j]['xmin']
                    patchXmax = patchsList[j]['xmax']
                    patchYmin = patchsList[j]['ymin']
                    patchYmax = patchsList[j]['ymax']
                    if(
                      (patchsList[j]['selected'] == 0) and
                      ((xmin-thresh == patchXmin and xmax-thresh == patchXmax) or
                       (xmin+thresh == patchXmin and xmax+thresh == patchXmax) or
                       (ymin+thresh == patchYmin and ymax+thresh == patchYmax) or
                       (ymin-thresh == patchYmin and ymax-thresh == patchYmax) or
                       (xmin-thresh == patchXmin and ymin-thresh == patchYmin and xmin == patchXmax and ymin == patchYmax) or
                       (xmax == patchXmin and ymax == patchYmin and xmin+thresh == patchXmax and ymin+thresh == patchYmax) or
                       (xmax == patchXmin and ymin-thresh == patchYmin and xmax+thresh == patchXmax and ymin == patchYmax) or
                       (xmin-thresh == patchXmin and ymax == patchYmin and xmin == patchXmax and ymax+thresh == patchYmax))
                    ):
                        patchsList[j]['selected'] = 1
                        square['xmin'] = patchXmin
                        square['xmax'] = patchXmax
                        square['ymin'] = patchYmin
                        square['ymax'] = patchYmax
                        square['score'] = patchsList[j]['score']
                        neighbours.append(square)
                        neighCounter += 1
                        flag = 0
    return neighbours


# get neighbours array as input and finalize the coordinates of banana zone and return
# xmin, ymin, xmax, ymax
# filename is the file that bounding box will be drawn on it
def findBananaCoordinates(neighbours, filename):
    coordinates = {}
    if(len(neighbours) == 0):
        coordinates['filename'] = str(filename) + '.png'
        coordinates['detected'] = 0
        coordinates['xmin'] = 0
        coordinates['ymin'] = 0
        coordinates['xmax'] = 0
        coordinates['ymax'] = 0
        return coordinates
    xmin = 500
    xmax = 0
    ymin = 500
    ymax = 0
    for m in range(0, len(neighbours)):
        if neighbours[m]['xmin'] < xmin:
            xmin = neighbours[m]['xmin']

        if neighbours[m]['xmax'] > xmax:
            xmax = neighbours[m]['xmax']

        if neighbours[m]['ymin'] < ymin:
            ymin = neighbours[m]['ymin']

        if neighbours[m]['ymax'] > ymax:
            ymax = neighbours[m]['ymax']

    coordinates['filename'] = str(filename) + '.png'
    coordinates['detected'] = 1
    coordinates['xmin'] = xmin
    coordinates['ymin'] = ymin
    coordinates['xmax'] = xmax
    coordinates['ymax'] = ymax
    return coordinates
